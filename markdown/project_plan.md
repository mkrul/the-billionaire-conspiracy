# Interactive Influence Map Visualization: Library Selection and Project Plan

## Library Evaluation and Selection

**Requirements Recap:** The project needs a network visualization (~16–20 nodes, possibly more) with rich interactivity and storytelling features. Key needs include zoom/pan, theming (dark mode, CSS animations), clickable nodes to isolate focus (highlight a node and its immediate connections, fading others), hover tooltips or detail modals, filtering (e.g. show only first-degree connections), animated highlights (e.g. pulsing connections), all driven by a static JSON/CSV data source. Integration should be possible in a non-React web environment (avoiding heavy framework overhead).

Given these criteria, let's compare the candidate libraries:

- **Cytoscape.js:** A pure JavaScript network graph library known for flexibility. It supports CSS-like styling of nodes/edges and user interaction events out-of-the-box. This means themes (e.g. dark mode) can be applied via style objects or classes, similar to CSS, and you can animate visual changes (Cytoscape allows smooth transitions for style changes and an animate API for motions). It excels at interactive features: you can easily attach click/hover handlers to nodes and edges, enabling behaviors like isolating a node’s neighborhood or showing tooltips. Cytoscape also includes many built-in layout algorithms (force-directed, circle, grid, etc.) which is useful for arranging the graph intuitively. It’s designed to handle even large graphs (100k+ elements) efficiently, so our 20–30 node graph is trivial in comparison. The main drawback noted is its documentation can feel dense or less beginner-friendly. However, it is an actively maintained project with comprehensive docs (and even a book-like website) – _one source rates its documentation as great_, though it may require some learning curve to master advanced features. Overall, Cytoscape.js appears to cover all required features (theming, animation, interactions) with no need for external frameworks.
- **Sigma.js:** A modern JS library for graph visualizations, built on the Graphology graph data structure. Sigma is very performant (WebGL based) and can easily handle large numbers of nodes, which is overkill for our size but good for future scaling. Its documentation is considered approachable, with a clean API and examples. Sigma supports panning, zooming, and basic interactions (clicking nodes, etc.) out-of-the-box. It allows customization of node and edge appearance and has a plugin system for extending features. However, Sigma **lacks built-in animation support** for smooth transitions – for example, there’s no simple way to animate node color changes or edge pulsation with a duration. Achieving animations would require manual coding (e.g. using timers or the plugin from v1). Additionally, Sigma’s built-in layouts are limited (primarily force-directed layouts like ForceAtlas). For a storytelling map, where we may want custom positioning or a specific layout, this could mean extra work. In summary, Sigma.js is strong in documentation and base interactions, but its lack of native animation and fewer layout options are notable drawbacks for our needs (which emphasize animated storytelling).
- **React Flow:** A React-based library for node-link diagrams and flowcharts. It provides a powerful feature set (drag-drop node positioning, highly customizable node rendering via React components, etc.) and could handle our interactions. However, using React Flow would essentially require building a React app or embedding a React component into the site. Given the project explicitly prefers not to use React unless unavoidable, React Flow becomes an **overkill** choice. It would introduce unnecessary complexity (maintaining React state, bundling the app) for a relatively small static graph. The flexibility it offers isn’t needed since libraries like Cytoscape or Sigma can already handle the required interactions without React. Thus, we rule out React Flow due to integration overhead in a non-React context.
- **Chart.js + Graph Plugin:** While Chart.js is great for charts, its network graph plugin is quite limited. It’s primarily meant for simple graph drawings and lacks the fine-grained interactivity and styling we need. Animations in Chart.js are geared toward chart transitions, not custom network pulses or interactive isolation of nodes. Also, customizing behavior (like clicking a node to filter others) would be non-trivial. This option doesn’t meet the flexibility requirements.
- **Tableau (or other BI tools):** Tableau was considered and rightly ruled out. It excels at quick visualizations but is not suited for custom interactive behavior or theming beyond its templates. It cannot embed the kind of custom click behaviors or animated storytelling needed here, and it introduces licensing costs and iframes that limit customization. We need a code-driven approach for full control, so Tableau is not a fit.

**Recommended Choice:** **Cytoscape.js** emerges as the best fit for this project. It meets all the core requirements: interactive events, CSS-like theming, and the ability to create animations/visual effects, all in a self-contained JS library (no framework needed). Its rich styling system will handle dark mode and highlight animations, and it has the flexibility to implement custom behaviors (tooltip on hover, isolate on click, filtering) through its API. While its documentation may require some effort, it is comprehensive and the active community (StackOverflow, extensions like popper for tooltips, etc.) can help overcome learning hurdles. Sigma.js was a close consideration due to its documentation and simplicity, but the lack of built-in animation capabilities and fewer layout options tilt the decision toward Cytoscape, which offers more out-of-the-box for a highly interactive, animated storytelling map.

## Implementation Plan

With Cytoscape.js as the chosen library, the following project plan outlines how to implement the interactive influence map. The plan is broken into milestones, each addressing specific features and considerations. The approach will ensure we meet all requirements and allow for future scalability and maintenance.

### 1. **Project Setup and Data Preparation**

- **Library Integration:** Include Cytoscape.js in the project. This can be done via a CDN script tag or by bundling the library using a build tool (if the larger site has a build pipeline). No React setup is needed – we can initialize Cytoscape in a plain JS file once the DOM is ready.
- **Data Format:** Define a static JSON (or CSV converted to JSON) that contains all nodes and relationships. For example, create a JSON with a list of node objects (with unique IDs, labels, type like "person" or "organization", etc.) and a list of edge objects (with source, target, relationship description, maybe a category or strength attribute). This JSON will serve as the single source of truth for the graph structure and content (e.g. any quotes or URLs related to a node or edge can be included as fields here).
- **Container Setup:** Add an HTML container (e.g. a `<div id="influenceGraph"></div>`) in the host site where the graph will render. Apply CSS styles to ensure this container fills the desired area and can be toggled to dark/light backgrounds as needed (for theming).

### 2. **Base Graph Rendering**

- **Initialization:** Write a script to load the JSON data and initialize Cytoscape with it. Use `cytoscape({ container: ..., elements: ... })` to populate the graph with nodes and edges from the JSON. At this stage, also define a default style for nodes and edges. For example, nodes could have a default color, size, label styling, etc., which can later be overridden by theme or interaction. Cytoscape’s style capabilities (similar to CSS selectors) will be used – e.g. one selector for all nodes, one for all edges, and perhaps classes for different types (person vs company nodes might get different shapes or colors).
- **Layout:** Apply an initial layout. For a small graph, a force-directed layout (like Cytoscape’s “cose” or “fcose” layout) or a preset layout can be used. If the narrative calls for a specific arrangement (say grouping certain nodes together manually), we can specify positions in the data or use a combination of a layout and manual tweaking. Cytoscape supports many layouts out-of-the-box, which we can experiment with to find one that best visualizes the influence connections. We can also enable Cytoscape’s zoom and pan controls here (it supports pinch/scroll zoom and drag pan by default). Ensure that zoom/pan is working by testing that the user can drag the canvas and scroll to zoom.
- **Verification:** At this point, we have a static graph rendered. Verify that all nodes and edges appear, labels are readable (or use tooltips if labels would clutter – possibly only show labels on hover to reduce initial clutter). Also confirm performance is smooth (with 20 nodes it will be; but test zooming and panning to confirm no jank).

### 3. **Styling and Theming (Dark Mode)**

- **CSS-Like Theming:** Leverage Cytoscape’s styling to create a **dark mode** theme. For instance, set the graph background to a dark color, node colors to contrasting light shades, and edge colors to muted greys or bright colors as needed. Because Cytoscape styles can be updated dynamically, we can create two style objects (one for dark, one for light) and switch between them based on a toggle. Another approach is to define CSS variables in the host page and have Cytoscape read those for colors (Cytoscape can take color values via JS, so simply recomputing style is fine).
- **Animations in Style:** Define some transition properties in the style so that certain visual changes animate smoothly. For example, we can set a transition duration (e.g. 0.3s) for properties like opacity or color on nodes and edges. This way, when we change a node’s class to “faded” or “highlighted,” it will fade in/out or glow gradually rather than abruptly.
- **Responsive Design:** Ensure the graph container can resize (if needed) and Cytoscape can be called to fit the graph to container. Also, if the site supports switching theme globally, hook into that event to apply the appropriate Cytoscape style set. Test the dark theme by toggling it and verifying all elements (background, node/edge colors, label colors) update accordingly.

### 4. **Interactivity – Node Click Isolation**

- **Click Event Handling:** Use Cytoscape’s event API to listen for clicks on nodes. When a node is clicked, implement the “focus/isolate” behavior. The logic can be: on click, get the clicked node and its connected edges and neighbor nodes (Cytoscape allows selecting a node’s neighborhood easily, e.g. `node.neighborhood()` to get adjacent elements). Then, add a CSS class (e.g. `.faded`) to all nodes and edges that are _not_ part of this node’s neighborhood, and conversely add a class (e.g. `.highlight`) to the clicked node and its direct connections. The `.faded` class style would set low opacity on those elements, effectively fading them out, while the highlighted ones could be emphasized (maybe a brighter color or thicker border). Because we set transition durations in styling, this fade can happen with a smooth animation.
- **Isolate View:** Optionally, we can also “zoom in” to the selected node’s area. Cytoscape has a `cy.fit(elements)` function that zooms/pans to fit a given set of elements in view. We might call `cy.fit(neighborhood, 50)` to focus on the node and its neighbors with some margin. This creates an isolated view of that subgraph.
- **Reset on Background Click:** When the user clicks on an empty background (or perhaps a “reset” button), restore the full view. This means remove the added classes and call `cy.fit()` on the full graph again. This ensures the user can return to the overview after examining one person/corporation’s connections.
- **User Guidance:** A UX touch here is to maybe indicate the clicked state, e.g. keep the clicked node visually distinguished (a different color or slight pulsating outline) so the user knows which node is in focus. Also, provide a clear way to exit the focus (maybe an on-screen button “Show All” or instruct that clicking background resets). This prevents the user from getting “stuck” looking at one subset.

### 5. **Interactivity – Hover Tooltips and Detail Modals**

- **Hover Tooltips:** Implement hover tooltips to show quick info (like a name or a brief title). Cytoscape itself doesn’t natively show tooltips, but we can easily integrate this. A simple method is to use the `mouseover` (or `taphover` for mobile) event on nodes to trigger a tooltip. We can either use a Cytoscape extension like **cytoscape-popper with Tippy.js** (which positions a DOM tooltip near a node using Popper.js) or manually position a tooltip div. Using an extension is convenient: cytoscape-popper will give us the screen coordinates of an element, and then we can use Tippy.js to show a styled tooltip with the node’s data (e.g. the person’s title or a snippet of a quote). On `mouseout`, hide the tooltip. This provides additional context on hover without cluttering the graph with all labels.
- **Detail Modals on Click:** For deeper information (like showing quotes, URLs, and detailed relationship text), a modal on click is appropriate. We can differentiate single-click (for isolate focus) versus double-click or a specific UI gesture for the modal. For instance, single-click isolates the node, and then in the focused state the user could click an “info” icon or double-click the node to open a modal. The modal (which can be a custom HTML overlay or a lightbox) would display detailed info about the person or organization: e.g. their description, quotes from the JSON data, links to sources, and perhaps a list of their connections. Since this is outside Cytoscape’s canvas, we build it using regular HTML/CSS, populating it with data from the JSON (we can store the necessary info in each node’s data and retrieve on click). Ensure the modal is styled consistently (matching dark theme if active) and is scrollable if content is long.
- **Edge Tooltips/Info:** If needed, apply similar interactions for edges. For example, hovering over a connection line could show a small tooltip with the relationship description (“Partnered on Project X”, “Mentored by”, etc.), and clicking an edge might open a brief modal or sidepanel describing that relationship in detail (with a source URL if available). This adds to the storytelling by letting users explore not just entities but the links between them.
- **Testing UX:** Check that tooltips don’t flicker or obstruct the view. We might add a slight delay to tooltips to avoid overwhelming the user when moving the mouse across many nodes. For modals, ensure clicking outside or a close button will dismiss them. Also consider mobile behavior: on touch devices, “hover” doesn’t exist, so we might use a tap to show tooltip or directly show the modal on tap with perhaps a different trigger to isolate (maybe a long press to isolate on mobile). These considerations will improve accessibility and overall UX.

### 6. **Filtering and Legend Controls**

- **Degree Filter:** Add an option to filter the graph to first-degree connections of a selected node. This overlaps with the isolate feature, but here it could be more of a global filter mode. For example, a toggle switch labeled "Show only direct connections" – when turned on, the graph will, if a node is selected, hide any nodes that are more than 1 hop away. If no specific node is selected, this control could be disabled or it could mean “for any selection I make, automatically hide others.” However, this might confuse users, so it’s likely better handled as part of the isolate-on-click logic. We can treat the isolate feature as the mechanism to show first-degree connections, which we already implemented.
- **Category Filter:** If our data includes categories (say different types of influence relationships or different groups of people), consider adding checkboxes or a legend to filter by category. For instance, a legend listing "Politicians, Corporations, Non-profits" and toggling each will hide/show those nodes. Cytoscape allows filtering either by removing elements or by styling them invisible. A quick way is to give each node a class like `.type-corporation` etc., and then adjust the style or visibility based on filter state. This way, users can simplify the view to certain categories if the story calls for it.
- **Highlight Search:** Another possible feature is a search box to find a node by name. Cytoscape’s API can query elements by label or ID, allowing us to locate and highlight a node if a user searches for "Alice" for example. While not explicitly asked, this could be helpful as the graph grows. We could implement this as an enhancement if needed, by zooming to the found node and perhaps flashing it briefly to catch the eye.

### 7. **Animated Highlights and Storytelling Aids**

- **Pulsing Connections:** To emphasize certain relationships or to draw attention sequentially (for storytelling), implement a pulse animation on nodes or edges. With Cytoscape, one approach is toggling a class on and off periodically. For example, to pulse an edge, define a CSS class `.pulse` that changes an edge’s opacity or color, and use a JavaScript interval to add/remove that class on the target edge every second, creating a blinking effect. Because style transitions are supported, this can appear as a smooth pulse rather than a hard blink. Another approach is using the Cytoscape animation API (e.g. `edge.animate({ style: {...} }, { duration: ..., loop: ... })`), which can tween properties. We can decide on the easiest method.
- **Sequence Animations:** If the visualization is part of a narrative (e.g., step 1: highlight A influences B, step 2: then B influences C, etc.), we can script a sequence. For instance, use `setTimeout` or async functions to first highlight one connection, then after a delay, highlight the next, and so on, effectively guiding the user through a story. Cytoscape’s ability to manipulate style on the fly helps here. We might also center the view on different parts of the graph as the story progresses (using `cy.panTo()` or `cy.fit()` with specific elements in sequence). These animations can be triggered when the page loads or when the user scrolls to this section of the site (if part of a larger page).
- **Performance Check:** Animations can be performance-intensive if overused, but with ~20 nodes it’s no problem. Still, we’ll test that the pulsing or sequential highlights do not cause any lag. Cytoscape can handle continuous animations well for small graphs, but we’ll ensure not to animate too many elements at once or provide an option to pause animations if they distract.

### 8. **Integration into the Larger Site**

- **Embedding:** Since the site/app is non-React, we will integrate the graph by simply including the necessary JS and CSS in the site’s resources. For example, include the Cytoscape.js script (and any extensions like cytoscape-popper and tippy.js for tooltips) in a `<script>` tag. Our custom graph script (which initializes the cytoscape instance and implements all the above interactions) can be included as a separate file or inline script at the bottom of the page (after the container div). This way, when the page loads, our script runs and renders the graph.
- **Modular Structure:** It’s wise to encapsulate our graph logic to avoid polluting global scope. We can write the code in an IIFE or as a module if the site supports ES6 modules. This also makes it easier to maintain. If the site uses a build system, we’ll incorporate our code there; if not, a straightforward inclusion works.
- **Styling Integration:** Ensure that the Cytoscape container and any added UI controls (buttons, toggles for filters, modals) inherit the site’s CSS or are styled to match. For example, use the site’s CSS classes for buttons for our filter toggle, so it doesn’t look out of place. Also, if the site has a global dark mode toggle, connect it to our graph’s theme switch (so the graph seamlessly switches theme along with the rest of the site).
- **Responsiveness & Scaling:** Test the graph embedded in various contexts – different page layouts, resized windows, and mobile devices. Cytoscape’s canvas should resize with the container, but we might need to call `cy.resize()` on window resize events to redraw properly. Also, on smaller screens, consider simplifying the graph (maybe hide some labels or use a different layout) to ensure usability. We might implement a different configuration for mobile (e.g. disable hover tooltips in favor of tap interactions, increase font sizes for readability, etc.).

### 9. **Testing and Refinement**

- **User Testing:** Once all features are in place, conduct testing with actual users or team members. Observe if the interactions are intuitive. For instance, do users notice they can click nodes? If not, we might add a subtle hint (like a brief tooltip that says "Click nodes to explore connections" that appears on first load). Ensure the isolate and reset mechanism is clear.
- **Content Verification:** Double-check that all quotes, URLs, and info in tooltips/modals are correctly pulled from the data and formatted. This is important for the storytelling aspect – the data should be presented clearly when a user seeks it (no broken links or undefined fields).
- **Performance with More Nodes:** To be safe for future scaling, test the visualization with, say, 50-100 nodes (by adding dummy data) to ensure interactions remain smooth. Cytoscape can handle it easily, but this helps verify that our event handlers or animations don’t have any bottlenecks (e.g. an inefficient loop). If performance issues arise, we can optimize by limiting the number of elements we manipulate at once (though unlikely needed for this scale).
- **Cross-Browser Check:** Ensure compatibility across common browsers (Chrome, Firefox, Safari, Edge) since rendering and events can sometimes differ slightly on canvas-based visuals. Cytoscape is broadly compatible, but testing ensures a consistent experience.

### 10. **Deployment and Future Enhancements**

- **Deployment:** Deploy the updated site with the embedded Cytoscape graph. Monitor for any runtime errors or user feedback. Having analytics or at least some error logging on the page can catch if something goes wrong (like a tooltip not found, etc.).
- **Maintenance:** Document the data format and how to update it. For example, provide instructions for adding a new node or connection in the JSON, so that future updates to the influence map (as the story evolves) can be done easily without breaking the visualization. Cytoscape will simply need to be re-initialized or provided with updated elements if the data changes.
- **Scaling Considerations:** If the project ever grows beyond a “slightly larger” graph (say into hundreds of nodes or a constantly changing dataset), we might revisit the choice of library or architecture. Cytoscape can still handle a few hundred nodes fine, but we might start to use features like clustering or pagination of the graph view. For now, with ~20 nodes, we are well within safe limits.
- **UX Enhancements:** Consider adding a mini-map (overview thumbnail) if the graph area becomes large on the page – Cytoscape has an extension for a minimap. Also, think about guided tours: we could implement a guided step-by-step highlight that narrates the influence chain (perhaps using a slideshow or annotations on the graph). These can further enhance the storytelling goal of the project.

By following this plan, we leverage Cytoscape.js to achieve a highly interactive, customizable influence map that can be embedded seamlessly into the existing site. The milestones ensure that we start from a solid foundation (data and basic graph) and incrementally add the interactive layers: isolating nodes, tooltips/modals for rich info, filtering controls, and animations for emphasis. Throughout, we keep theming and integration in mind so the visualization feels like a natural part of the site. The end result will be a compelling, user-explorable network that illuminates the relationships in a story, with smooth UX and room to grow.

**Sources:**

- Focal Analytics – _Top 10 JS Libraries for Knowledge Graph Visualization_ (Cytoscape.js offers CSS-like styling and supports rich user interactions); (Cytoscape vs Sigma: extensive layouts and large graph performance).
- Cylynx Blog – _JS Graph Libraries Comparison_ (Sigma.js plugin system enables added features like animation; Cytoscape has a broad feature set with a moderate learning curve).
- Memgraph Engineering – _Graph Visualization Tool Research_ (Discussion on Sigma.js and Cytoscape capabilities; Cytoscape uses DOM-based rendering with many layouts; Sigma excels in WebGL performance but fewer built-in layouts).
- Official Cytoscape.js Documentation (demonstrating styling and animation support, e.g. transition-duration for smooth visual updates).
- Official Sigma.js Documentation (shows base interactivity like zoom, pan, click, and notes availability of plugins for extended features).
